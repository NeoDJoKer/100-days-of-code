# #100DaysOfCode Log - Round 1 - Jo

The log of my #100DaysOfCode challenge. Started on [December 4, Wednesday, 2019].

## Log
 
### Day 1: December 4, Wednesday

**Today's Progress**: Started working on an Election code where it records the number of vote for each party.

**Thoughts** Though I have code with python before, now that I start learning about python memory model, I finally know how python actually manage their variable for mutable/immutable data 

**Link(s) to work**
1. Check my github: https://github.com/NeoDJoKer/Election

### Day 2: December 5, Thursday

**Today's Progress**: I finish a few function of Election class of the code

**Thoughts** Interactive computing service such as Jupyter and Google Collab is really helpful for testing and debugging the code

**Link(s) to work**
1. Check my github: https://github.com/NeoDJoKer/Election

### Day 3: December 6, Friday

**Today's Progress**: I finish a few function of Election class of the code

**Thoughts** Interactive computing service such as Jupyter and Google Collab is really helpful for testing and debugging the code. Also type annotation using typing module really help understand the input and output of each code, making debugging and developing code much easier.

**Link(s) to work**
1. Check my github: https://github.com/NeoDJoKer/Election

### Day 4: December 7, Saturday

**Today's Progress**: I start working on C++ by doing problem from MIT OCW courses.

**Thoughts** Implementing ADT is important because it help organize the data. And with C++, it make the code run faster if memory is properly manage. In comparison, Python may be easier to implement, but is not as efficient as C++

**Link(s) to work**
1. Check my github: https://github.com/NeoDJoKer/CppPractice/tree/master/DataStructure

### Day 5: December 8, Sunday

**Today's Progress**: I want to try challeneging myself by doing mock coding interview on HackerEarth. The problem is to create superdrome. Even though my code is finish, it was not fast enough. In the end, I did not have enough time to optimize it.

**Thoughts** Speed is really important in programming. It is necessary to figure out roughly how to start, then optimize it before actually start coding. I feel like I need to practice more competitive coding.

### Day 6: December 9, Monday

**Today's Progress**: I practice more coding problem in C++ on Codewars and HackerEarth

### Day 7: December 10, Tuesday

**Today's Progress**: I practice more coding problem in C++ on Codewars and HackerEarth

### Day 8: December 12, Thursday

**Today's Progress**: I practice more coding problem in C++ on Codewars and HackerEarth. Also, I am looking at how to implement Hash Table

**Thoughts** A lot of problem (especially interview question) can be solve efficiently using Hash Table. The runtime of it is O(1)

### Day 9: December 13, Friday

**Today's Progress**: Did some practice problem on Hash Table on HackerEarth

### Day 10: December 14, Saturday

**Today's Progress**: I did some problem on codewars to improve my problem solving skills

### Day 11: December 15, Sunday

**Today's Progress**: I start working on my recursion project using C++. I have implement Insertion sort.

**Thoughts** Recurision may not be the most efficient algorithm because of the overhead that it call, but it simplify the problem and make it easier the programmer to program it. Sorting is also really important. In almost every problem, it involves some kind of data. Sorting will help speed up the code by accessing the data you want easier.

**Link(s) to work**
1. Check my github: https://github.com/NeoDJoKer/CppPractice/tree/master/Recursion

### Day 12: December 16, Monday

**Today's Progress**: I continue working on my recursion project and implement Selection and Bubble Sort.

**Thoughts** Different sorting algorithms have their own advantage/disadvantage. Knowing which to use is crucial.

**Link(s) to work**
1. Check my github: https://github.com/NeoDJoKer/CppPractice/tree/master/Recursion

### Day 13: December 17, Tuesday

**Today's Progress**: For a quick change, I start doing example of Matlab and Simulink code. I want to see how to apply it to control problem

### Day 14: December 18, Wednesday

**Today's Progress**: Did a challenge on codewars to turn decimal number into factorial number system, and vice versa.

**Thoughts** Factorail number system is pretty fascinating. Now I know there are more than just normal base number system, but it can also be dynamic (as long as we know the rule of its growth)

### Day 15: December 19, Thursday

**Today's Progress**: I am studying for interview question using "Cracking the Coding Interview" book. Really recommed this book.

**Thoughts** The book give a pretty clear explanation on how to approach a problem, not just interview, but it could apply to solving real programming problem. Start with simple answer, and keep optimizing it until it reach the speed you think is what human can process and solve it normally.

### Day 16: December 20, Friday

**Today's Progress**: I learn about bit manipulation and hash table. Then start learning Tensorflow on Udacity.

**Thoughts** Bit manipulation may come up on interview. It's also the basic building block of assembly code.

Tensorflow, now with Keras, help people get start on Machine Learning and build the model really quickly. It is really useful for developing model for your AI problem without having to go through all the coding part.

### Day 17: December 21, Saturday

**Today's Progress**: Learn more about TensorFlow and test it on Google Collab

### Day 18: December 22, Sunday

**Today's Progress**: Learn more about TensorFlow and test it on Google Collab

### Day 19: December 24, Tuesday

**Today's Progress**: Finish with TensorFlow courses and now moving on to how to desig OOP on Python

### Day 20: December 26, Thursday

**Today's Progress**: Implement merge sort on C++ for my recursion project!

**Thoughts** Merge sort is more efficient than previous sorting I done becuase of how it use divide and conquer technique. When implementing, it is a little different than how I would describe it because I did not create additional array, but use the original array and specify the location of the "smaller" array.

**Link(s) to work**
1. Check my github: https://github.com/NeoDJoKer/CppPractice/tree/master/Recursion

### Day 21: December 28, Saturday

**Today's Progress**: Get Excited! I'm now starting a new project, Path Planning! I choose to go with Python using Pygame to implement my front-end

**Thoughts** I always want to do robotics relate project to improve my robotics knowledge with coding. When deciding wheter to use python or c++, I look into the front-end and available simulation that I can use to make it interactive. I was inspired by a youtube video of someone implement A* with pygame (https://www.youtube.com/watch?v=jl5yUEdekEM) and also a website for path planning visualizer (https://clementmihailescu.github.io/Pathfinding-Visualizer/). I plan to do the same.

**Link(s) to work**
1. Check my github: https://github.com/NeoDJoKer/PathPlanning

### Day 22: December 29, Sunday

**Today's Progress**: I get pygame to create the map for me

**Thoughts** Game engine is pretty interesting. How the layers work and the pixel move to create an illusion of the game is new to me. I was considering game engine like Unity or Unreal Engine (which are what I usually see on my game LOL), but pygame would be a good start. Also Unity did not support C++ (or it required some work to get it to code in C++) In the future, I will probably use Unreal Engine to work on my project since it support C++ and I want to have more experience in that languange.

### Day 23: January 3, Friday

**Today's Progress**: I work on the back-end of path planning by using google collab and jupyter. Finally, I implement the Breath-First Search

**Thoughts** There are multiple path planning algorithm out there, which stem from graph theory. For my project though, each move to the next cell will cost only 1. However, in real world, the cost could be different and it get complicate. Though this is a good start, I should learn more about graph thoery to go in depth into path planning in general.

### Day 24: January 5, Sunday

**Today's Progress**: Finalizing Breath-First Search

### Day 25: January 6, Monday

**Today's Progress**: Implementing Depth-First Search, Dijkstra, and Forward/Backward Value Iteration

**Thoughts** Most of the code is similar, I just have to modified the algorithm a little bit to make it work. Though for more complex problem with different cost, this won't be that easy.

### Day 26: January 7, Tuesday

**Today's Progress**: Finally Finish A*! Pretty cool algorithm.

**Thoughts** A* is the best planning algorithm because it use heuristics to help decide the plan. For more complex case, this would be really useful.




